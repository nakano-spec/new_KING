#!/usr/bin/env node

/**
 * Module dependencies.
 */

const { SQL_exec } = require( '../db/SQL_module');

 var { app,sessionMiddleware } = require('../app');
 var debug = require('debug')('sotuken:server');
 var http = require('http')
 http.globalAgent.maxSockets = 100;
 var express = require('express');
 const path = require('path');
 var ExcelJS = require('exceljs');
 var validator = require('validator');
 var fs = require('fs');
 var poolCluster = app.get('pool');
 var pool = poolCluster.of('MASTER');
 var async = require('async');
 var crypto = require('crypto');
 const sha512 = crypto.createHash('sha512');
 const encoding = 'hex';
 const sanitizeHtml = require('sanitize-html');
 
 
 /**
  * Get port from environment and store in Express.
  */
 
 var port = normalizePort(process.env.PORT || '3000');
 app.set('port', port);
 
 /**
  * Create HTTP server.
  */
 var server = http.createServer(app);
 var { Server } =require("socket.io");
 var io = new Server(server, {
  polling: { interval: 1000 }
 });

 /**
  * Listen on provided port, on all network interfaces.
  */
 
 server.listen(port,'0.0.0.0', () => {console.log('サーバ起動しました。\nlistening on "[このサーバ機のIPアドレス]:3000"');});
 server.on('error', onError);
 server.on('listening', onListening);
 
 /**
  * Normalize a port into a number, string, or false.
  */
 
 function normalizePort(val) {
   var port = parseInt(val, 10);
 
   if (isNaN(port)) {
     // named pipe
     return val;
   }
 
   if (port >= 0) {
     // port number
     return port;
   }
 
   return false;
 }
 
 /**
  * Event listener for HTTP server "error" event.172.18.96.162
  */
 
 function onError(error) {
   if (error.syscall !== 'listen') {
     throw error;
   }
 
   var bind = typeof port === 'string'
     ? 'Pipe ' + port
     : 'Port ' + port;
 
   // handle specific listen errors with friendly messages
   switch (error.code) {
     case 'EACCES':
       console.error(bind + ' requires elevated privileges');
       process.exit(1);
       break;
     case 'EADDRINUSE':
       console.error(bind + ' is already in use');
       process.exit(1);
       break;
     default:
       throw error;
   }
 }
 
 /**
  * Event listener for HTTP server "listening" event.
  */
 
 function onListening() {
   var addr = server.address();
   var bind = typeof addr === 'string'
     ? 'pipe ' + addr
     : 'port ' + addr.port;
   debug('Listening on ' + bind);
 }
 
 const mysql = require('mysql2');
 const store = require('store');
 const { connect } = require('http2');
 const { namespace } = require('store');
 const { param, data } = require('jquery');


  // Socket.ioにセッションミドルウェアを適用する
  io.use((socket, next) => {
      sessionMiddleware(socket.request, {}, next);
  });

 
 io.on('connection', (socket) => {//ページが繋がったとき
   console.log(socket.request.session);
   const mysql_setting = {
    host :'sql307.infinityfree.com',//172.18.96.186,172.18.96.162
    user :'if0_37673553',
    password :'Nakano.0426',
    database :'if0_37673553mydb',
   }
   
   const connection = mysql.createConnection(mysql_setting);
   connection.connect();

   //cryptoでの暗号化 public/javascripts/login.jsが関係している
   socket.on('crypto1',(data) =>{
      sha512.update(data);
      var sha512Hash = sha512.digest(encoding);
      io.emit('crypto',sha512Hash); 
   })

   
   //書き換えたバージョン　負荷テスト的にこちらの書き方がいい
  async function SQL_exec(data) {
    return new Promise((resolve, reject) => {
      pool.query(data.sql, data.value, (err, result) => {
        if (err) {
          console.error('Database query failed:', err);
          return reject(new Error('データベースクエリに失敗しました'));
        }
        resolve(result);
      });
    });
  }

  //SQLモジュール引数なし
  async function SQL_exec2(data){
    return new Promise((resolve,reject) =>{
      pool.getConnection(function(err,connection){
        if (err) {
          return reject(err); // ここでのエラー処理が不足していた
        }
        connection.query(data.sql,function(err,result){
          if (err) return reject(err);
          connection.release()
          resolve(result)
        })
      })
    })
  }

  
     //新規登録処理　今は使われていない
     /*socket.on('new_btnclick', (name,pass1,pass2) => {g
      if(pass1 == pass2) {

        socket.on('new_select1',async function () {
          var new_select1 = { spl:'select username from users where username = ?',value:[1]
          }
          try{ const result = await new_select1(data);
            socket.emit('select1_result'.result);
          }
          catch(error){
            console.error(error)
        socket.emit('select1_result,error');
          }  
        })
        //var new_select1 = "select username from users where username = ?;"
        socket.on('new_select2',async function () {
          var new_select2 = { spl:'select password from users where password = ?;',value:[1]
          }
          try{ const result = await new_select2(data);
            socket.emit('select2_result'.result);
          }
          catch(error){
            console.error(error)
        socket.emit('select2_result,error');
          }  
        })
        var new_select2 = "select password from users where password = ?;"
        var new_insert1 = "insert into users values (?,?,?,'2022{01>01','2022{01>01');"
        var kensaku = "SELECT MIN(user_ID + 1100) AS user_ID FROM users WHERE (user_ID + 1100) NOT IN (SELECT user_ID FROM users);"
        connection.query(new_select1,name,(err, new_result1, fields) => {
          connection.query(new_select2,pass1,(err, new_result2, fields) => {
            if(new_result1.length < 1 && pass1.length >= 8 && pass1.length <= 16 && pass1.length != 0 && name.length >= 2 && name.length <= 10) {
              connection.query(kensaku,(err,kensaku1,fields)=>{
                if(err){
                  console.log(err);
                }
                var user = kensaku1[0].user_ID;
                connection.query(new_insert1,[user,name,pass1],(err, new_result3, fields) => {
                  if(err){
                    console.log(err);
                  }
                  var new_flug = 1;
                  io.emit('new_flug',new_flug);
              })
              })
            }
          })
        })
      }
    })*/

     //csvファイルでの問題登録処理
     socket.on('filedata', async (data) =>{
      try{
        var da = "a";
        var moni = 0;
        var question_name = data[0];
        var question_text = data[1];
        var sen1 = data[2];
        var sen2 = data[3];
        var sen3 = data[4];
        var sen4 = data[5];
        var seikai = data[6];
        var seiID = 0;
        var kaiID = 0;
        if(data[7] != "なし"){
          var picture = data[7];
        }else{
          var picture = "";
        }
        var SQL = {
          sql:"select MIN(question_ID  + 1) AS question_ID from question_table where (question_ID + 1) NOT IN (SELECT question_ID from question_table);",
        }
        var question_ID = await SQL_exec2(SQL);
        var SQL_data ={
          sql:"insert into question_table values(?,?,?,?)",
          value:[question_ID,question_name,question.text,picture]
        }
        var result = await SQL_exec(SQL_data);
        io.emit('kanryou');
      }catch(err){
        console.log(err);
      }
    })  
    
    //採点結果の修正処理
    socket.on('kekkasyusei',async (set1)=>{
     var user_ID = socket.request.session.user.username;
      var update_result ={
        sql: "update answer_table set result = ? where user_ID =?;",
        value:[]
      }
      async.eachSeries(set1, async function(selection, cb) {
        try{
          var userID = selection.user_ID; 
          var selectedValue = selection.selectedValue; 
          update_result.value = [userID,selectedValue]
          var result = await SQL_exec(update_result)
          cb();
        }catch(error){
          console.log(error)
        }
      }, function(err) {
        if (err) {
          // 更新中にエラーが発生した場合
          console.log(err);
        } else {
          // すべての更新が成功した場合
          io.emit('result_display2', {username:user_ID});
        }
      });
    })
    
    //問題の回答を追加する処理
    socket.on('kaitoutuika', async (selections) => {
      var userID = socket.request.session.user.username;
      var SQL_data ={
        sql:"select room_ID from room_table where user_ID = ?",
        value:[userID]
      }
      var update_SQL = {
        sql:"UPDATE answer_table SET result = '○' WHERE question_ID = ? AND answer = ?",
        value:[]
      }
      var room_ID = await SQL_exec(SQL_data);
      SQL_data.sql = "select question_ID from question_log where room_ID = ? and question_status = 1"
      SQL_data.value = [room_ID]
      var question_ID = await SQL_exec(SQL_data);
      SQL_data.sql = "insert into correct table value(?,?)"
      async.eachSeries(selections, async function(selection,cb){
        try{
          SQL_data.value = [question_ID,selection.answer]
          var result = await SQL_exec(SQL_data);
          update_SQL.value = [question_ID,selection.answer]
          result = await SQL_exec(update_SQL);
          cb()
        }catch(err){
          console.log(err);
        }
      }, function(err) {
        if (err) {
          // 更新中にエラーが発生した場合
          console.log(err);
        } else {
          // すべての更新が成功した場合
          io.emit('yomikomi', {username: userID}); 
        }
      })
    });

      //問題の解答を削除する機能
      socket.on('kaitousakuzyo', (deletions) => {
        var userID = socket.request.session.user.username;
        var SQL_data = {
          sql:"DELETE FROM correct_table WHERE answer = ?",
          value:[]
        }
        async.eachSeries(deletions, async function(deletion, callback) {
            // 正解を削除
            SQL_data.value = [deletion.answer];
            var delete_result = await SQL_exec(SQL_data)
        }, function(err) {
            if (err) {
                console.error("エラーが発生しました: ", err);
            } else {
                io.emit('yomikomi',{username: userID}); 
            }
        });
      });
  
     //問題情報を手入力で追加する処理    
     socket.on('question_add', async (array) => {   
      try {
          const name = array[0];
          const mondaibun = array[1];
          let sen1 = array[2];
          let sen2 = array[3];
          let sen3 = array[4];
          let sen4 = array[5];
          const seikai = array[6];
          let picture = array[7] !== "なし" ? array[7] : "";
          let kaiID = 0;
          
          if (sen1 === "なし") {
              sen1 = "";
              sen2 = "";
              sen3 = "";
              sen4 = "";
              kaiID = 1;
          }
  
          const getMonIDQuery = { 
              sql: "SELECT MIN(mon_ID + 1) AS mon_ID FROM mondai_LIST WHERE (mon_ID + 1) NOT IN (SELECT mon_ID FROM mondai_LIST);",
          };
          const getSeikaiIDQuery = {
              sql: "SELECT MIN(seikai_ID + 1) AS seikai_ID FROM seikai_LIST WHERE (seikai_ID + 1) NOT IN (SELECT seikai_ID FROM seikai_LIST);",
          };

          const monIDResult = await SQL_exec2(getMonIDQuery);
          const monID = monIDResult[0].mon_ID;
  
          const seikaiIDResult = await SQL_exec2(getSeikaiIDQuery);
          const seikaiID = seikaiIDResult[0].seikai_ID;
  
          const insertMondaiQuery = {
              sql: "INSERT INTO mondai_LIST VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?);",
              value: [monID, name, mondaibun, sen1, sen2, sen3, sen4, picture, kaiID, seikai, da]
          };
          await SQL_exec(insertMondaiQuery);
          console.log('Inserted into mondai_LIST successfully.');
  
          const insertSeikaiQuery = {
              sql: "INSERT INTO seikai_LIST VALUES (?, ?, ?);",
              value: [seikaiID, monID, seikai]
          };
          await SQL_exec(insertSeikaiQuery);
          console.log('Inserted into seikai_LIST successfully.');
  
          socket.emit('complete');
      } catch (error) {
          console.error('Error during montuika process:', error);
          socket.emit('error');
      }
    });
  

    socket.on('clear', async () => {
      try {
          const userID = socket.request.session.user.username;
          
          let SQL_data = { sql: "select room_ID from room_table where user_ID = ?", value: [userID] };
          const roomID = await SQL_exec(SQL_data);
          
          SQL_data = { sql: "select question_ID from question_log where room_ID = ? and question_status = 1", value: [roomID] };
          const questionID = await SQL_exec(SQL_data);
  
          SQL_data = { sql: "update question_log set question_status = 0 where question_status = 1 and room_ID = ? and question_ID = ?", value: [roomID, questionID] };
          await SQL_exec(SQL_data);

          SQL_data = { sql: "select distinct user_ID from login_log where user_ID <> ? and room_ID = ?", value: [userID, roomID] };
          const students = await SQL_exec(SQL_data);
  
          const deleteAnswerSQL = { sql: "DELETE FROM answer_table WHERE user_ID = ? and question_ID = ?", value: [] };
          for (const student of students) {
              deleteAnswerSQL.value = [student.user_ID, questionID];
              await SQL_exec(deleteAnswerSQL);
          }
          // Emit modoru event to signal completion
          socket.emit('modoru');
      } catch (err) {
          console.error("Error in clear process:", err);
      }
    });
     
     //学生解答送信処理　
     //学生解答を表示するhyouji3.ejs,及び画面遷移するためindex.ejsに送信する 
     //public/javascripts/hyouji3.js,public/javascripts/index.jsが関係している(今は直書きされている)
     socket.on('hyou',(c) =>{
         io.emit('hyouji',c);
      })
      
     //結果発表表示送信処理　結果発表ボタンが押されると起動する
     //送信元:mondai4.ejsとmondai6.ejs,送信先:hyouji3.ejs,index.ejs
     socket.on('result_display',()=>{
        const username = socket.request.session.user.username;
        io.emit('result_display2',{username:username});
     })
     
     //hash化する関数
     function digestMessage(message) {
      return new Promise((resolve, reject) => {
        try {
          const hash = crypto.createHash('sha512'); // SHA-256 ハッシュ関数を使用
          hash.update(message); // メッセージでハッシュを更新
          const hashHex = hash.digest('hex'); // ハッシュを16進数の文字列として取得
          resolve(hashHex); // ハッシュ値を返す
        } catch (error) {
          reject(error); // エラーが発生した場合は、rejectを使用してエラーを返す
        }
      });
    }

        socket.on('login', async (data) => {
          try {
              const username = sanitizeHtml(data.username);
              let password = sanitizeHtml(data.password);
              
              password = await hashPassword(password); // ハッシュ化されたパスワード
              // Fetch user data from user_table
              const loginSelect = { 
                sql: "select EXISTS(select 1 from user_table where user_ID =? and password=?) as login_result",
                value:[username,password]
              };
              const users = await SQL_exec(loginSelect);
              if(users[0].login_result == 1){
                const loginFlag = 1;
                var user_data = {
                    sql: "select user_type from user_table where user_ID=?",
                    value: [username]
                }
                var user_SQL = await SQL_exec(user_data);
                switch (user_SQL[0].user_type) {
                    case 1: // User type 1
                        try {
                            console.log("start");
                            const roomIDData = { sql: "SELECT room_ID FROM room_table WHERE user_ID = ?", value: [username] };
                            const roomIDResult = await SQL_exec(roomIDData);
                            const roomID = roomIDResult[0].room_ID;
        
                            const insertLog = { sql: "INSERT INTO login_log(room_ID, user_ID) VALUES (?, ?);", value: [roomID, username] };
                            await SQL_exec(insertLog);
        
                            const updateLogTime = { sql: "UPDATE login_log SET log_time = CURRENT_TIMESTAMP WHERE user_ID = ?", value: [username] };
                            await SQL_exec(updateLogTime);
        
                            socket.request.session.student = { username: username };
                            socket.request.session.studentroom_ID = data.selectedOption;
                            socket.request.session.save();
                            
                            io.to(socket.id).emit('login_flug2', loginFlag, username);
                        } catch (error) {
                            console.log(error);
                            io.emit('new_flug', 0);
                        }
                        break;
                    case 2: // User type 2
                        try {
                            socket.request.session.user = { username: username };
                            socket.request.session.save();
                            const roomID_SQL ={
                              sql:"select r.room_ID from room_table r,user_table u where r.user_ID = u.user_ID and u.user_name = ?",
                              value:[data.selectedOption]
                            }
                            const room_ID = await SQL_exec(roomID_SQL);
                            const roomIDvalue = room_ID[0].room_ID;
                            const insertStudentLog = { sql: "INSERT INTO login_log(user_ID,room_ID,log_time) VALUES (?,?,CURRENT_TIMESTAMP);", value: [username,roomIDvalue] };
                            await SQL_exec(insertStudentLog);
        
                            io.to(socket.id).emit('login_flug', loginFlag, username);
                        } catch (error) {
                            console.log(error);
                            io.emit('login_error');
                        }
                        break;
                    case 3: // User type 3
                        try {
                            const getUserIDData = { sql: "SELECT user_ID FROM user_table WHERE user_name = ?", value: [data.selectedOption] };
                            const userIDResult = await SQL_exec(getUserIDData);
                            const userID = userIDResult[0].user_ID;
                            console.log(userID);
                            const getRoomIDData = { sql: "SELECT room_ID FROM room_table WHERE user_ID = ?", value: [userID] };
                            const roomIDResult = await SQL_exec(getRoomIDData);
                            const roomID = roomIDResult[0].room_ID;
                            console.log(roomID);
                            const insertAdminLog = { sql: "INSERT INTO login_log(room_ID, user_ID) VALUES (?, ?);", value: [roomID, username] };
                            await SQL_exec(insertAdminLog);
        
                            io.to(socket.id).emit('login_flug2', loginFlag, username);
                        } catch (error) {
                            console.log(error);
                            io.emit('login_error');
                        }
                        break;
                    default:
                      console.log("start3");
                      io.to(socket.id).emit('new_flug', 0);
                      break;
                  }
              }else{
                io.to(socket.id).emit('new_flug', 0);
              }
          } catch (error) {
              console.log("Error in login process:", error);
              io.to(socket.id).emit('login_error');
          }
        });
   
        socket.on('search_accounts', function(searchTerm) {
          var searchTerm1 = sanitizeHtml(searchTerm);
          const sql = 'SELECT user_ID, user_name, password,log_time FROM user_table WHERE user_ID LIKE ? OR user_name LIKE ? OR password LIKE ?';
          connection.query(sql, [`%${searchTerm1}%`, `%${searchTerm1}%`, `%${searchTerm1}%`], function(err, results) {
              if (err) {
                  // エラー処理
                  console.log(err);
                  socket.emit('search_results', []);
              } else {
                  // 検索結果をクライアントに送信
                  socket.emit('search_results', results);
              }
          });
        });

      socket.on('account_delete',async function(user_ID){
        var user_ID1 = sanitizeHtml(user_ID);
        var delete_data={
          sql:"delete from user_table where user_ID = ?", 
          value:[user_ID1]
         }
         try{
          var result=await SQL_exec(get_id_data);
          socket.emit('delete_result',question_id);
         }
         catch(error){
          console.error(error);
          socket.emit('account_delete',error);
         }
         io.emit('delete_complete');
      });
      
      
      socket.on('owa2',() =>{
         io.emit('end');
      })


      socket.on('pageupdate',(page_update_No) =>{
        switch(page_update_No){
          case 1:
            async.waterfall([
              function(callback){
                socket.request.session.Before_page = "main.ejs";
                socket.request.session.page = "mondai2.ejs";
                console.log(socket.request.session.page);
                socket.request.session.save();
                callback(null,"done");
              },
              function(result,callback){
                io.emit('page_updatecomplete'); 
              }
            ])
            break;
          case 2:
              socket.request.session.Before_page = "mondai2.ejs";
              socket.request.session.page = "main.ejs";
              socket.request.session.save();
              io.emit('page_updatecomplete2'); 
              break;
            case 3:
                socket.request.session.Before_page = 1;
                socket.request.session.page = 2;
                socket.request.session.save();
                io.emit('page_updatecomplete3'); 
                break;
            case 4:
                socket.request.session.Before_page = 1;
                socket.request.session.page = 2;
                socket.request.session.save();
                io.emit('page_updatecomplete4'); 
                break;
            case 5:
                socket.request.session.Before_page = "main.ejs";
                socket.request.session.page = "account.ejs";
                socket.request.session.save();
                io.emit('page_update2complete'); 
                break;
            case 6:
                  socket.request.session.Before_page = "main.ejs";
                  socket.request.session.page = "Question_manager.ejs";
                  socket.request.session.save();
                  io.emit('page_update3complete'); 
                  break;
        }
      })

      socket.on('mondai_btnclick', async function(mondai, o, room_ID) {
        // 入力値のサニタイズ
        const mondai1 = sanitizeHtml(mondai);
        const oSanitized = sanitizeHtml(o);
        const room_IDSanitized = sanitizeHtml(room_ID);
        
        console.log(room_IDSanitized);
    
        if (mondai1 !== '') {
            const pool = poolCluster.of('MASTER');
    
            // SQLクエリの定義
            const get_status = "SELECT COUNT(*) AS cnt FROM question_log WHERE room_ID = ? AND question_status = 1;";
            const question_reset = "UPDATE question_log SET question_status = 0 WHERE room_id = ?;";
            const get_id_sql = "SELECT question_ID FROM question_table WHERE question_name = ?;";
            const mondai_sentaku = "INSERT INTO question_log (question_id, room_id, question_status) VALUES (?, ?, 1);";
            const mondai_select = "SELECT question_table.question_ID, question_text FROM question_table, question_log WHERE question_log.question_ID = question_table.question_ID AND question_status = 1 AND room_ID = ?;";
    
            try {
                const connection = await pool.getConnection();
    
                // 現在の出題状況を確認
                const status_data = { sql: get_status, value: [room_IDSanitized] };
                const statusResult = await SQL_exec(status_data);
                const status_count = statusResult[0].cnt;
                console.log("count:", status_count);
    
                // 出題中の問題があればリセット
                if (status_count >= 1) {
                    const reset_data = { sql: question_reset, value: [room_IDSanitized] };
                    await SQL_exec(reset_data);
                    console.log("Question status reset.");
                }
    
                // question_IDの取得
                const get_id_data = { sql: get_id_sql, value: [mondai1] };
                const questionIDResult = await SQL_exec(get_id_data);
                const q_ID = questionIDResult[0].question_ID;
    
                // question_logへの挿入
                const sentaku_data = { sql: mondai_sentaku, value: [q_ID, room_IDSanitized] };
                await SQL_exec(sentaku_data);
                console.log("Inserted into question_log.");
    
                // 選択した問題のデータを取得
                const mondai_data = { sql: mondai_select, value: [room_IDSanitized] };
                const mondaiResult2 = await SQL_exec(mondai_data);
                socket.emit('mondai_select', mondaiResult2);
    
                // 完了フラグを送信
                const flag = 1;
                io.emit('mondai_kekka', flag);
    
                connection.release(); // コネクションを解放
            } catch (error) {
                console.error('Error during mondai_btnclick process:', error);
                socket.emit('error', { message: 'Error in mondai_btnclick process', error });
            }
        } else {
            console.log("内容がありません");
            try {
                // question_IDの取得
                const get_id_data = { sql: get_id_sql, value: [mondai1] };
                const questionIDResult = await SQL_exec(get_id_data);
                const q_ID = questionIDResult[0].question_ID;
    
                // question_logへの挿入
                const sentaku_data = { sql: mondai_sentaku, value: [q_ID, room_IDSanitized] };
                await SQL_exec(sentaku_data);
                console.log("Inserted into question_log.");
    
                // 選択した問題のデータを取得
                const mondai_data = { sql: mondai_select, value: [room_IDSanitized] };
                const mondaiResult2 = await SQL_exec(mondai_data);
    
                // 成功した場合はフラグを1で返す
                const flag = 1;
                io.emit('mondai_kekka', flag);
                socket.emit('mondai_select', mondaiResult2);
            } catch (error) {
                console.error('Error during alternative mondai_btnclick process:', error);
                socket.emit('error', { message: 'Error in mondai_btnclick process', error });
    
                // 失敗した場合はフラグを0で返す
                const flag = 0;
                io.emit('mondai_kekka', flag);
            }
        }
    });
    
      /*socket.on('mondai_btnclick',async function(mondai,o,room_ID) {
        var mondai1 = sanitizeHtml(mondai);
        var o = sanitizeHtml(o);
        var room_ID = sanitizeHtml(room_ID);
        console.log(room_ID)
        if(mondai != ''){
          var pool = poolCluster.of('MASTER');
          
          let get_status = "select count(*) as cnt from question_log where room_ID = ? AND question_status = 1;"
          let question_reset = "update question_log set question_status = 0 WHERE room_id = ?;"
          let get_id_sql = "select question_ID from question_table where question_name=?;"
          let mondai_sentaku = "insert into question_log(question_id,room_id,question_status) VALUES (?,?,1) ;"  //出題問題SQL
          var mondai_select = "select question_table.question_ID,question_text from question_table,question_log where question_log.question_ID=question_table.question_ID AND question_status = 1 AND room_ID = ?;" //選択した問題SQL
          
          console.log(room_ID); 
          
          pool.getConnection(async function(err,connection){
          if(err != null){
           console.log("db" + err);
           return;
          }
          var status_data={
           sql:get_status, 
           value:[room_ID]
          }
          try{
           var result=await SQL_exec(status_data);
           socket.emit('status_result',status_count);
          }
          catch{
           console.error(error);
           socket.emit('status_result',error);
          }
          console.log("count" + status_count[0].cnt);
          if(status_count[0].cnt >= 1){
           console.log("count" + status_count[0].cnt);
           var reset_data={
            sql:question_reset, 
            value:[room_ID]
           }
           try{
            var result=await SQL_exec(reset_data);
            socket.emit('reset_result',reset_result);
           }
           catch{
            console.error(error);
            socket.emit('reset_result',error);
           }
           var get_id_data={
            sql:get_id_sql, 
            value:[mondai1]
           }
           try{
            var result=await SQL_exec(get_id_data);
            socket.emit('status_result',question_id);
           }
           catch{
            console.error(error);
            socket.emit('status_result',error);
           }
           var q_ID = question_id[0].question_ID;
           var sentaku_data={
            sql:mondai_sentaku, 
            value:[q_ID,room_ID]
           }
           try{
            var result=await SQL_exec(sentaku_data);
            socket.emit('question_insert',question_result);
           }
           catch{
            console.error(error);
            socket.emit('question_insert',error);
           }
           connection.commit((err) =>{if(err){connection.rollback(() =>{throw console.log('error');});}})
           var mondai_data={
            sql:mondai_select, 
            value:[room_ID]
           }
           try{
            var result=await SQL_exec(mondai_data);
            socket.emit('mondai_select',mondai_result2);
           }
           catch{
            console.error(error);
            socket.emit('mondai_select',error);
           }
           var flag = 1;
           io.emit('mondai_kekka',flag);
        }})
        }else{
         console.log("naiyo--");
          var get_id_data={
           sql:get_id_sql, 
           value:[mondai1]
          }
          try{
           var result=await SQL_exec(get_id_data);
           socket.emit('get_id_result',question_id);
          }
          catch{
           console.error(error);
           socket.emit('status_result',error);
          }
         var q_ID = question_id[0].question_ID;
         var sentaku_data={
          sql:mondai_sentaku, 
          value:[qID,room_ID]
         }
         try{
          var result=await SQL_exec(sentaku_data);
          socket.emit('sentaku_result',sentaku_result);
         }
         catch{
          console.error(error);
          socket.emit('sentaku_result',error);
         }
         if(err){
          console.log("sentaku_err" + err);
         }
         connection.commit((err) =>{
          if(err){connection.rollback(() =>{throw console.log('error');});}
         })
         connection.query(mondai_select,room_ID,(err,mondai_result2,fields)=>{
          if(err){
           var flag = 0;
           io.emit('mondai_kekka',flag);
          }
          connection.commit((err) =>{
           if(err){connection.rollback(() =>{throw console.log('error');});}
          })
          var ID = mondai_result2[0].question_ID;
          var flag = 1;
          io.emit('mondai_kekka',flag);	 
         })
      	}
      })
    })*/

       
      socket.on('question_release',()=>{
        io.emit('questionPosted');
      });
      
      
      socket.on('search_room',async function(){
        username = socket.request.session.user.username;
        var data={
          sql:"select room_ID from room_table where user_ID =?", 
          value:[username]
        }
        try{
          var result=await SQL_exec(data);
          io.emit('room_IDget',result[0].room_ID);
        }
        catch(error){
          console.error(error);
          socket.emit('room_ID_result',error);
        }
      })
      
      socket.on('kiroku', async (m1, kaitou1) => {
        const kaitou = sanitizeHtml(kaitou1);
        const pool = poolCluster.of('MASTER');
    
        async.waterfall([
            // コネクションを取得
            function(callback) {
                pool.getConnection((err, connection) => {
                    if (err) {
                        console.log(err);
                        return callback(err);
                    }
                    callback(null, connection);
                });
            },
            // room_ID を取得
            async function(connection, callback) {
                try {
                    const roomResult = await SQL_exec({
                        sql: "SELECT room_ID FROM login_log WHERE user_ID = ?;",
                        value: [m1]
                    });
                    const room = roomResult[0].room_ID;
                    callback(null, connection, room);
                } catch (error) {
                    console.error("Error getting room_ID:", error);
                    connection.release();
                    callback(error);
                }
            },
            // question_ID を取得
            async function(connection, room, callback) {
                try {
                    const questionResult = await SQL_exec({
                        sql: "SELECT question_ID FROM question_log WHERE room_ID = ? AND question_status = 1;",
                        value: [room]
                    });
                    const question = questionResult[0].question_ID;
                    callback(null, connection, question);
                } catch (error) {
                    console.error("Error getting question_ID:", error);
                    connection.release();
                    callback(error);
                }
            },
            // 回答が既に存在するか確認
            async function(connection, question, callback) {
                try {
                    const answerExistsResult = await SQL_exec({
                        sql: "SELECT * FROM answer_table WHERE user_ID = ? AND question_ID = ?;",
                        value: [m1, question]
                    });
    
                    if (answerExistsResult.length > 0) {
                        connection.release();
                        socket.emit('insert_error');
                        return callback(new Error('Answer already exists'));
                    }
                    callback(null, connection, question);
                } catch (error) {
                    console.error("Error checking answer existence:", error);
                    connection.release();
                    callback(error);
                }
            },
            // 正解データを取得
            async function(connection, question, callback) {
                try {
                    const correctAnswerResult = await SQL_exec({
                        sql: "SELECT answer FROM correct_table WHERE question_ID = ?;",
                        value: [question]
                    });
                    const correct_data = correctAnswerResult[0].answer;
                    callback(null, connection, question, correct_data);
                } catch (error) {
                    console.error("Error getting correct answer:", error);
                    connection.release();
                    callback(error);
                }
            },
            // 回答を判定
            function(connection, question, correct_data, callback) {
                const judgement = kaitou === correct_data ? "○" : "✕";
                callback(null, connection, question, judgement);
            },
            // 回答を answer_table に挿入
            async function(connection, question, judgement, callback) {
                try {
                    const insertResult = await SQL_exec({
                        sql: "INSERT INTO answer_table(user_ID, question_ID, answer, ans_pics_flag, result) VALUES (?, ?, ?, 0, ?);",
                        value: [m1, question, kaitou, judgement]
                    });
                    socket.emit('data_result', insertResult);
                    callback(null, insertResult);
                } catch (error) {
                    console.error("Error inserting answer:", error);
                    socket.emit('data_result', error);
                    connection.release();
                    callback(error);
                } finally {
                    connection.release();
                }
            }
        ], function(err, result) {
            if (err) {
                console.error("Error in kiroku process:", err);
            } else {
                socket.emit('end');
            }
        });
      });
    
      /*socket.on('kiroku',(m1,kaitou1) =>{
        var kaitou = sanitizeHtml(kaitou1)
        var pool = poolCluster.of('MASTER');
        async.waterfall([
          function(callback){
            pool.getConnection(function(err, connection) {
              if (err) {
                  console.log(err);
                  return callback(err);
              }
              callback(null, connection);
            });
          },
          function(connection,callback){
            var sql = 'select room_ID from login_log where user_ID = ?;';
            Socket.on('request_room',async function(){
              var data={
                sql:"select room_ID from login_log where user_ID = ?", 
                value:[m1]
              }
              try{
                var result=await SQL_exec(data);
                socket.emit('result2',result);
              }
              catch{
                console.error(error);
                socket.emit('result2',error);
              }
            /*connection.query(sql,m1,(err,result,fields)=>{
              if(err){
                console.log(err);
              }
              var room = result[0].room_ID;
              callback(null,connection,room);
            })
          },
          function(connection,room,callback){
            var select = 'select question_ID from question_log where room_ID = ? and question_status = 1;';
            Socket.on('request_question',async function(){
              var data={
                sql:"select question_ID from question_log where room_ID = ? and question_status = 1", 
                value:[room]
              }
              try{
                var result=await SQL_exec(data);
                socket.emit('answer_result',result);
              }
              catch{
                console.error(error);
                socket.emit('answer_result',error);
              }
              /*
            connection.query(select,room,(err,result2,field)=>{
              if(err){
                console.log(err);
              }
              var question = result2[0].question_ID;
              callback(null,connection,question);
            })
          },
          function(connection, question, callback) {
            var checkAnswerExists = 'SELECT * FROM answer_table WHERE user_ID = ? AND question_ID = ?;';
            Socket.on('user_answer',async function(){
              var data={
                sql:"SELECT * FROM answer_table WHERE user_ID = ? AND q_log_ID = ?", //引数を変えて
                value:[question]
              }
              try{
                var result=await SQL_exec(data);
                socket.emit('answer_result',result);
              }
              catch{
                console.error(error);
                socket.emit('answer_result',error);
              }
            })/*
            connection.query(checkAnswerExists, [m1, question], (err, result) => {
                if (err) {
                    console.log(err);
                    connection.release();
                    return callback(err);
                }
                if (result.length > 0) {
                    // 既に回答が存在する場合
                    connection.release();
                    socket.emit('insert_error');
                    return callback(new Error('Answer already exists'));
                }
                // 回答が存在しない場合、処理を続行
                callback(null, connection, question);
         },
          function(connection,question,callback){
            var correct = 'select answer from correct_table where question_ID = ?';
            Socket.on('request_answer',async function(){
              var data={
                sql:"select answer from correct_table where question_ID = ?",
                value:[question]
              }
              try{
                var result=await SQL_exec(data);
                socket.emit('answer_result',result);
              }
              catch{
                console.error(error);
                socket.emit('answer_result',error);
              }
            })/*
            connection.query(correct,question,(err,result3,fields)=>{
              if(err){
                console.log(err);
              }
              var correct_data = result3[0].answer;
              console.log(correct_data);
              callback(null,correct_data,question);
            })
          },
          function(correct_data,question,callback){
            var judgement = "✕";
            if(kaitou == correct_data){
              judgement = "○";
            }
            callback(null,question,judgement);
          },
          function(question,judgement,callback){
            var insert = "insert into answer_table(user_ID,question_ID,answer,ans_pics_flag,result) values(?,?,?,0,?);";
            socket.on('request_data',async function(){
              var data={
                sql:"insert into answer_table(user_ID,question_ID,answer,ans_pics_flag,result) values(?,?,?,0,?)",
                value:[m1,question,kaitou,judgement]
              }
              try{
                var result=await SQL_exec(data);
                socket.emit('data_result',result);
              }
              catch(error){
                console.error(error);
                socket.emit('data_result',error);
              }
          })
        }
      ],function(err,result5){
        if(err){
          console.log(err);
        }else{
          socket.emit('end');
        }
      })
    });*/

      socket.on('request_data',async function(){
        var data={
          sql:"select g.question_genre,g.question_years,q.question_name from question_table q,genre_table g where g.qualification_name = ? and q.question_ID = g.question_ID",
          value:[qualificationName]
        }
        try{
          var result=await SQL_exec(data);
          socket.emit('data_result',result);
        }
        catch{
          console.error(error);
          socket.emit('data_result',error);
        }
      })

      socket.on('request_name',async function(){
        var data={
          sql:"select g.question_genre,q.question_name from question_table q,genre_table g where g.question_years = ? and q.question_ID = g.question_ID",
          value:[qualificationName]
        }
        try{
          var result=await SQL_exec(data);
          socket.emit('name_result',result);
        }
        catch{
          console.error(error);
          socket.emit('name_result',error);
        }
      })

      socket.on('request_genre',async function(){
        var data={
          sql:"select g.question_genre from question_table q,genre_table g where q.question_name = ? and q.question_ID = g.question_ID",
          value:[qualificationName]
        }
        try{
          var result=await SQL_exec(data);
          socket.emit('genre_result',result);
        }
        catch{
          console.error(error);
          socket.emit('genre_result',error);
        }
      })
    
      socket.on('logout',function(){
        socket.request.session.destroy(function(err) {
          if (err) {
              console.error("セッション破棄中にエラーが発生しました。", err);
              return res.status(500).send("セッションの破棄に失敗しました。");
          }
          socket.emit('logout_complete');
        });
      });

      // ユーザー追加手動
      socket.on('Add_user_manually', async (data) => {
        try {
            // パスワードをSHA-256でハッシュ化
            password = hashPassword(data.password)

            // ユーザー情報をuser_tableに挿入
            const insertUserQuery = {
                sql: "INSERT INTO user_table(user_ID, user_name, password, user_type) VALUES (?, ?, ?, ?);",
                value: [data.userID, data.username, password, data.usertype]
            };
            await SQL_exec(insertUserQuery);

            console.log('User data inserted successfully.');

            
            // room_tableにユーザーと部屋情報を追加する
            if (data.usertype == 2) {
                const insertRoomQuery = {
                    sql: "INSERT INTO room_table(room_ID, user_ID) VALUES (?, ?);",
                    value: [data.room_name, data.userID]
                };
                await SQL_exec(insertRoomQuery);
                console.log('Room data inserted successfully.');
            }

            io.emit('Add_user_manually_Complete'); 
        } catch (error) {
            console.error('Error adding user manually:', error); 
            socket.emit('insert_result', error);
        }
      });

      // Insert files handling for room_table insertion
      /*socket.on('insert_files', async (data) => {
        const insertRoomData = {
            sql: "INSERT INTO room_table(room_ID, user_ID) VALUES (?, ?);",
            value: [data.room_name, data.userID]
        };

        try {
            const result = await SQL_exec(insertRoomData);
            socket.emit('insert_result', result);
        } catch (error) {
            console.error('Insert files error:', error);
            socket.emit('insert_result', error);
        }
      });*/
     
      function hashPassword(password) {
        const sha256 = crypto.createHash('sha512');
        sha256.update(password);
        return sha256.digest('hex');
      }

      // CSVパーサーの仮定（CSVをJSONに変換する関数など）
          function parseCSV(csvData) {
            const lines = csvData.split('\n'); // 改行で分割して各行に
            const headers = lines[1].split(','); // 2行目をヘッダーとして使用
            const result = [];
        
            for (let i = 2; i < lines.length; i++) { // 3行目からデータ行
                const obj = {};
                const currentLine = lines[i].split(',');
                
                if (!currentLine[currentLine.length - 1] || currentLine[currentLine.length - 1].trim() === '') {
                  break;
                }
                for (let j = 0; j < headers.length; j++) {
                  if (headers[j] === 'パスワード') {
                    obj[headers[j]] = hashPassword(currentLine[j]);
                } else if(headers[j] === 'USER_TYPE'){
                   // USER_TYPE の値をINT型に変換して obj に追加
                  obj[headers[j]] = parseInt(currentLine[j], 10);
                }else{
                  obj[headers[j]] = currentLine[j];
                }
                }
                result.push(obj);
            }
            return result;
        };

        socket.on('insert_files',async function(){
          const normalizedData = data.data.replace(/\r\n/g, '\n');
          const records = parseCSV(normalizedData); // CSVデータをパースしてレコードの配列に変換
          const values = records.map(record => [record.学籍番号, record.名前, record.パスワード, record.アカウント区分]);
          var data={
            sql:"INSERT INTO user_table(user_ID,user_name,password,user_type) VALUES ?",
            value:[values]
          }
          try{
            var result=await SQL_exec(data);
            socket.emit('insert_result',result);
          }
          catch{
            console.error(error);
            socket.emit('insert_result',error);
          }
        })

       
      socket.on('searchQuery', async function(data) {
        var pool = poolCluster.of('MASTER');
        const query = '%' + data.query + '%';
        var data={
         sql:"select user_ID,user_name,log_time from user_table where user_ID LIKE ? OR user_name LIKE ? OR password LIKE ? OR log_time LIKE ?",
         value:[query,query,query,query]
        }
        try{
          var result=await SQL_exec(data);
          socket.emit('search_result',result);
        }
        catch(error){
          console.error(error);
          socket.emit('search_result',error);
        }
      });

      socket.on('search_question',async function(data) {
        var data = sanitizeHtml(data);
        const query = '%' + data + '%';
        var data={
          //SQL書き直し必要あり
          sql:"select g.qualification_name, g.question_genre, g.question_years, q.question_name, q.question_text, COALESCE(s.select_1, \'\') AS select_1, COALESCE(s.select_2, \'\') AS select_2, COALESCE(s.select_3, \'\') AS select_3, COALESCE(s.select_4, \'\') AS select_4, a.type_name, CASE WHEN q.picture_flag = 0 THEN \'\' ELSE p.pics_name END AS pics_name FROM question_table q LEFT JOIN select_table s ON q.question_ID = s.question_ID LEFT JOIN pics_table p ON q.question_ID = p.question_ID JOIN answer_type a ON q.type_ID = a.type_ID JOIN genre_table g ON q.question_ID = g.question_ID WHERE g.qualification_name LIKE ? OR g.question_genre LIKE ? OR g.question_years LIKE ? OR q.question_name LIKE ? OR q.question_text LIKE ? OR a.type_name LIKE ?",
          value:[query,query,query,query,query,query]
        }
        try{
          var result=await SQL_exec(data);
          socket.emit('question',result);
        }
        catch{
          console.error(error);
          socket.emit('question',error);
        }
        
       /* pool.getConnection(async function(err,connection){
          var data={
            sql:"select g.qualification_name, g.question_genre, g.question_years, q.question_name, q.question_text, COALESCE(s.select_1, \'\') AS select_1, COALESCE(s.select_2, \'\') AS select_2, COALESCE(s.select_3, \'\') AS select_3, COALESCE(s.select_4, \'\') AS select_4, a.type_name, CASE WHEN q.picture_flag = 0 THEN \'\' ELSE p.pics_name END AS pics_name FROM question_table q LEFT JOIN select_table s ON q.question_ID = s.question_ID LEFT JOIN pics_table p ON q.question_ID = p.question_ID JOIN answer_type a ON q.type_ID = a.type_ID JOIN genre_table g ON q.question_ID = g.question_ID WHERE g.qualification_name LIKE ? OR g.question_genre LIKE ? OR g.question_years LIKE ? OR q.question_name LIKE ? OR q.question_text LIKE ? OR a.type_name LIKE ?",
            value:[query,query,query,query,query,query]
          }
          try{
            var resut=await SQL_exec(data);
            socket.emit('select_qualo',result);
          }
          catch{
            console.log(error);
            socket.emit('select_quali',error);
          }
        })*/
      });

      socket.on('question_delete', async function(question_name) {
            async.waterfall([
                async function(callback) {
                    const data = {
                        sql: "SELECT question_ID FROM question_table WHERE question_name = ?",
                        value: [question_name]
                    };
    
                    try {
                        const result = await SQL_exec(data);
                        if (result.length === 0) {
                            return callback(new Error("Question not found"));
                        }
                        const question_ID = result[0].question_ID;
                        callback(null, question_ID);
                    } catch (error) {
                        console.error("Error fetching question_ID:", error);
                        callback(error);
                    }
                },
                async function(question_ID, callback) {
                    const deleteData = {
                        sql: "DELETE FROM question_table WHERE question_ID = ?",
                        value: [question_ID]
                    };
    
                    try {
                        await SQL_exec(deleteData);
                        callback(null);
                    } catch (error) {
                        console.error("Error deleting question:", error);
                        callback(error);
                    }
                }
            ], function(err) {
                if (err) {
                    socket.emit('error', err.message); 
                } else {
                    socket.emit('question_Complete'); 
                }
            });
        });
    

     //テスト用Socket.io
     socket.on('SQL_test',async function(){
        var data ={
          sql: 'select * from question_table where question_ID = ?',
          value: [1]
        }
        try{
          const result = await SQL_exec(data);
          socket.emit('test_result',result);
        }
        catch(error){
          console.error(error)
          socket.emit('test_result',error);
        }
     })

     socket.on('SQL_test2',async function(){
      var data ={
        sql: 'insert into user_table values(?,?,?,?)',
        value: ["HA03-1006","test","password",3]
      }
      try{
        const result = await SQL_exec(data);
        socket.emit('test_result',"success");
      }
      catch(error){
        console.error(error)
        socket.emit('test_result',"error")
      }
     })

     socket.on('SQL_test3',async function(){
      var data ={
        sql: 'update user_table set user_name = ? where user_ID = ?',
        value: ["ichimura","HA03-1006"]
      }
      try{
        const result = await SQL_exec(data);
        socket.emit("test_result","success");
      }
      catch(error){
        console.error(error)
        socket.emit('test_result',"error")
      }
     })

     socket.on('SQL_test4',async function(){
      var data ={
        sql: 'delete from user_table where user_name = ?',
        value: ["ichimura"]
      }
      try{
        const result = await SQL_exec(data);
        socket.emit("test_result","success");
      }
      catch(error){
        console.error(error)
        socket.emit('test_result',"error")
      }
     })

     socket.on('SQL_test5',async function(data){
      try{
        const result = await SQL_exec(data);
        socket.emit("test_result",result);
      }
      catch(error){
        console.error(error)
        socket.emit('test_result',"error")
      }
     })
   })
